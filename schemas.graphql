# Database for Harper Edge AI Example with MLOps
type Model @table @export {
	# Composite key: modelName:modelVersion (set by client)
	id: ID @primaryKey

	# Model metadata
	modelName: String @indexed
	modelVersion: String @indexed
	framework: String @indexed # "onnx" | "tensorflowjs" | "ollama"
	stage: String @indexed # "development" | "staging" | "production"
	# Model binary data (use Blob for large ONNX/TF models)
	modelBlob: Blob

	# Schema definitions (JSON stringified)
	inputSchema: String
	outputSchema: String
	metadata: String

	# Timestamps
	uploadedAt: Long @createdTime
}

type InferenceEvent @table @export {
	# Primary key - UUID for each inference
	id: ID @primaryKey # This will be the inferenceId
	# Model information
	modelName: String @indexed
	modelVersion: String @indexed
	framework: String @indexed

	# Request tracking
	requestId: String @indexed
	userId: String @indexed
	sessionId: String @indexed

	# Inference data (JSON stringified)
	featuresIn: String
	prediction: String
	confidence: Float

	# Performance
	latencyMs: Int

	# Feedback loop (nullable until feedback received)
	actualOutcome: String
	feedbackTimestamp: Long
	correct: Boolean

	# Timestamps
	timestamp: Long @createdTime @indexed
}

type BenchmarkResult @table @export {
	# Primary key - UUID for each benchmark run
	id: ID @primaryKey

	# Benchmark parameters
	taskType: String @indexed # e.g., "text-embedding", "image-classification"
	equivalenceGroup: String @indexed # e.g., "sentence-encoder", "resnet-variants"
	# Models compared (array of model keys: modelId:version)
	modelIds: String # JSON stringified array
	# Results (detailed metrics per model)
	results: String # JSON stringified object
	# Test data summary
	testDataSummary: String # JSON: { sampleCount, inputShape, description }
	iterations: Int

	# Metadata
	runBy: String # Optional user/system identifier
	notes: String # Optional notes about the benchmark
	# Timestamps
	timestamp: Long @createdTime @indexed
	completedAt: Long
}

type Feature @table @export {
	# Composite key: entityId:featureName (set by client)
	id: ID @primaryKey

	# Indexed fields for flexible querying
	# entityId can represent userId, sessionId, modelName, requestId, clientId, etc.
	entityId: String @indexed
	featureName: String @indexed

	# Feature value (JSON stringified to support any type)
	featureValue: String

	# Explicit timestamp from caller
	timestamp: Long
}

type ModelFetchJob @table @export {
	# Primary key - UUID for each fetch job
	id: ID @primaryKey
	jobId: ID @indexed # Same as id for query consistency

	# Source information
	source: String @indexed # "huggingface" | "url" | "filesystem"
	sourceReference: String @indexed # Model ID, URL, or file path
	variant: String # For Transformers.js: "default" | "quantized"

	# Target model information
	modelName: String @indexed
	modelVersion: String
	framework: String # "onnx" | "tensorflow" | "transformers" | "ollama"
	stage: String # "development" | "staging" | "production"

	# Status tracking
	status: String @indexed # "queued" | "downloading" | "processing" | "completed" | "failed"
	progress: Int # 0-100 percentage
	downloadedBytes: Long
	totalBytes: Long

	# Retry logic
	retryCount: Int
	maxRetries: Int
	lastError: String
	errorCode: String
	retryable: Boolean # Can this job be retried?

	# Metadata (JSON stringified, consistent with Model table)
	inferredMetadata: String # Auto-detected from source
	userMetadata: String # User-provided overrides

	# Webhook
	webhookUrl: String # Optional callback URL

	# Timestamps
	createdAt: Date @createdTime @indexed # FIFO queue ordering
	startedAt: Date
	completedAt: Date

	# Result
	resultModelId: String @indexed # Reference to Model table
}
